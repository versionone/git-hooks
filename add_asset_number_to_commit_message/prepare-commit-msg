#!/usr/bin/env node

/*
	Parse the current branch name for a VersionOne asset number
	and prepend the commit message.
*/

const { readFile, writeFile } = require('fs').promises
const { exec } = require('child_process')
const util = require('util')
const execPromise = util.promisify(exec)

const isComment = line => line[ 0 ] === '#'
const isNotComment = line => !isComment(line)
const _parse = lines => ({
	message: lines.filter(isNotComment).join('\n'),
	comments: lines.filter(isComment).join('\n'),
})
const parse = content => _parse(content.split('\n'))

const assetFormat = /[a-zA-Z]{1,3}-\d{5,}/
const matchText = match => match ? match[ 0 ] : ''
const assetForBranch = symbolicRef => matchText(
	assetFormat.exec(symbolicRef)
)

const references = (message, asset) =>message.indexOf(asset) >= 0

const formatMessage = (asset, message, comments) => `[${asset}] ${message.trim()}\n\n${comments.trim()}`

async function main(messageFilename) {
	const [
		{ stdout: symbolicRef },
		originalMessage,
	] = await Promise.all([
		execPromise('git symbolic-ref HEAD'),
		readFile(messageFilename, { encoding: 'utf8' }),
	])

	const asset = assetForBranch(symbolicRef)
	const { message, comments } = parse(originalMessage)

	if (asset && !references(message, asset)) {
		const newMessage = formatMessage(asset, message, comments)
		await writeFile(messageFilename, newMessage, { encoding: 'utf8' })
	}
}

main(...process.argv.slice(2))
