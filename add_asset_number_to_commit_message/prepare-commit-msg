#!/usr/bin/env node

/*
	Parse the current branch name for a VersionOne asset number
	and prepend the commit message.
*/

const { readFile, writeFile, access } = require('fs').promises
const { exec } = require('child_process')
const util = require('util')
const execPromise = util.promisify(exec)

const isComment = line => line[ 0 ] === '#'
const isNotComment = line => !isComment(line)
const _parse = lines => ({
	message: lines.filter(isNotComment).join('\n'),
	comments: lines.filter(isComment).join('\n'),
})
const parse = content => _parse(content.split('\n'))

const assetFormat = /[a-zA-Z]{1,3}-\d{5,}/
const matchText = match => match ? match[ 0 ] : ''
const assetForBranch = symbolicRef => matchText(
	assetFormat.exec(symbolicRef)
)

const references = (message, asset) =>message.indexOf(asset) >= 0

const formatMessage = (asset, message, comments) => `[${asset}] ${message.trim()}\n\n${comments.trim()}`

const exists = (path) => access(path).then(() => true).catch(() => false)

const getBranchNameEvenIfInteractiveRebase = async () => {
	try {
		const { stdout: branchName } = await execPromise('git symbolic-ref HEAD')
		return branchName
	} catch (e) {
		// maybe we have head-name file in rebase-merge or rebase-apply
		const rebaseSteps = ['rebase-merge', 'rebase-apply'];
		for (const rebaseStep of rebaseSteps) {
			const { stdout: rebasePath } = await execPromise(`git rev-parse --git-path ${rebaseStep}`);
			const rebasePathExists = await exists(rebasePath);
			if (rebasePathExists) {
				const headName = await readFile(`${rebasePath}/head-name`, { encoding: 'utf8' });
				return headName;
			}
		}
		// git 2.18 gives us an out
		const { stdout: rebasingLine } = await execPromise('git branch --list | head -1');
		return rebasingLine;
	}
}

async function main(messageFilename, type) {	
	const [
		symbolicRef,
		originalMessage,
	] = await Promise.all([
		getBranchNameEvenIfInteractiveRebase(),
		readFile(messageFilename, { encoding: 'utf8' }),
	])
	const asset = assetForBranch(symbolicRef)
	const { message, comments } = parse(originalMessage)

	if (asset && !references(message, asset)) {
		const newMessage = formatMessage(asset, message, comments)
		await writeFile(messageFilename, newMessage, { encoding: 'utf8' })
	}
}

main(...process.argv.slice(2))